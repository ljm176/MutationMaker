#    Copyright (c) 2020 Merck Sharp & Dohme Corp. a subsidiary of Merck & Co., Inc., Kenilworth, NJ, USA.
#
#    This file is part of the Mutation Maker, An Open Source Oligo Design Software For Mutagenesis and De Novo Gene Synthesis Experiments.
#
#    Mutation Maker is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

import copy
import itertools
import numpy as np
from mutation_maker.basic_types import AminoAcid
from typing import List, Tuple, Iterable, FrozenSet, Dict, Set, AbstractSet, Optional, Collection

from Bio.Data import CodonTable

from mutation_maker.codon_usage_table import Organism
from mutation_maker.usage_table import UsageTable


def count_same_bases(a: str, b: str) -> int:
    return (a[0] == b[0]) + (a[1] == b[1]) + (a[2] == b[2])


def can_degenerate(a: str, b: str) -> bool:
    return count_same_bases(a, b) == 2


class DegenerateCodon:
    def __init__(self, value, bases):
        self.value = value
        self.bases = frozenset(bases)

    def union(self, other):
        return back_lookup["".join(self.bases.union(other.bases))]

    def __key(self):
        return self.bases

    def __eq__(self, y):
        return self.__key() == y.__key()

    def __hash__(self):
        return hash(self.__key())

    def __str__(self):
        return self.value

    def __repr__(self):
        return self.__str__()


A = DegenerateCodon("A", {"A"})
C = DegenerateCodon("C", {"C"})
G = DegenerateCodon("G", {"G"})
T = DegenerateCodon("T", {"T"})
R = DegenerateCodon("R", {"A", "G"})
Y = DegenerateCodon("Y", {"C", "T"})
S = DegenerateCodon("S", {"G", "C"})
W = DegenerateCodon("W", {"A", "T"})
K = DegenerateCodon("K", {"G", "T"})
M = DegenerateCodon("M", {"A", "C"})
B = DegenerateCodon("B", {"C", "G", "T"})
D = DegenerateCodon("D", {"A", "G", "T"})
H = DegenerateCodon("H", {"A", "C", "T"})
V = DegenerateCodon("V", {"A", "C", "G"})
N = DegenerateCodon("N", {"A", "C", "G", "T"})
GAP = DegenerateCodon("_", set())

lookup = {
    "A": A,
    "C": C,
    "G": G,
    "T": T,
    "R": R,
    "Y": Y,
    "S": S,
    "W": W,
    "K": K,
    "M": M,
    "B": B,
    "D": D,
    "H": H,
    "V": V,
    "N": N,
    "_": GAP
}

back_lookup = {
    "A": A,
    "C": C,
    "G": G,
    "T": T,
    "AG": R, "GA": R,
    "CT": Y, "TC": Y,
    "CG": S, "GC": S,
    "AT": W, "TA": W,
    "GT": K, "TG": K,
    "AC": M, "CA": M,
    "CGT": B, "CTG": B, "GCT": B, "GTC": B, "TCG": B, "TGC": B,
    "AGT": D, "ATG": D, "GAT": D, "GTA": D, "TAG": D, "TGA": D,
    "ACT": H, "ATC": H, "CAT": H, "CTA": H, "TAC": H, "TCA": H,
    "ACG": V, "AGC": V, "CAG": V, "CGA": V, "GAC": V, "GCA": V,
    "ACGT": N, "ACTG": N, "AGCT": N, "AGTC": N, "ATGC": N, "ATCG": N,
    "TCGA": N, "TCAG": N, "TGCA": N, "TGAC": N, "TAGC": N, "TACG": N,
    "CTGA": N, "CTAG": N, "CGTA": N, "CGAT": N, "CAGT": N, "CATG": N,
    "GTCA": N, "GTAC": N, "GCTA": N, "GCAT": N, "GACT": N, "GATC": N,
    "_": GAP
}


class DegenerateTriplet:
    @staticmethod
    def get_all_non_degenerate_codons(codon: str) -> List[str]:
        """
        Converts a degenerate codon string to a list of non-degenerate codons.
        """
        pos1, pos2, pos3 = lookup[codon[0]], lookup[codon[1]], lookup[codon[2]]

        result: List[str] = []

        for base1 in pos1.bases:
            for base2 in pos2.bases:
                for base3 in pos3.bases:
                    result.append(base1 + base2 + base3)

        return result

    @staticmethod
    def degenerate_codon_to_aminos(codon: str, forward_table: dict) -> List[AminoAcid]:
        """
        Converts a degenerate codon string to a list of aminos generated by that codon.
        """
        assert len(codon) == 3


        non_degenerate_codons = DegenerateTriplet.get_all_non_degenerate_codons(codon)

        coded_aminos = [forward_table[c] for c in non_degenerate_codons]

        # Here we just make sure that no duplicate aminos were generated
        # by the degenerate codon
        #assert len(list(set(coded_aminos))) == len(coded_aminos)

        return list(set(coded_aminos))


class DegenerateTripletWithAminos:
    """
    Represents a possibly degenerate codon with a list of aminos generated by that codon.
    """
    base1: DegenerateCodon
    base2: DegenerateCodon
    base3: DegenerateCodon
    aminos: FrozenSet[str]

    def __init__(self, base1: DegenerateCodon, base2: DegenerateCodon,
                 base3: DegenerateCodon, aminos: Iterable[str]) -> None:
        self.base1 = base1
        self.base2 = base2
        self.base3 = base3
        self.aminos = frozenset(aminos)

    @staticmethod
    def parse_from_codon_string(codon: str, forward_table: dict) -> "DegenerateTripletWithAminos":
        assert len(codon) == 3

        aminos = DegenerateTriplet.degenerate_codon_to_aminos(codon, forward_table)
        return DegenerateTripletWithAminos.create_from_string(codon, aminos)

    @staticmethod
    def parse_multi_site_codons(site_sequence: List[Set[str]], forward_table: dict) -> List[Set["DegenerateTripletWithAminos"]]:
        """
        Convert a `SiteSequenceAminos` type of data structure to use `DegenerateTripletWithAminos`.
        """
        return [
            {
                DegenerateTripletWithAminos.parse_from_codon_string(codon, forward_table)
                for codon in site
            } for site in site_sequence
        ]

    @staticmethod
    def stringify_multi_site_codons(site_sequence: List[Set["DegenerateTripletWithAminos"]]) -> List[Set[str]]:
        """
        An inverse transformation of `parse_multi_site_codons`
        """
        return [
            {str(codon) for codon in site}
            for site in site_sequence
        ]

    @staticmethod
    def create_from_string(triplet: str, aminos: Iterable[str]) -> "DegenerateTripletWithAminos":
        """
        Creates a `DegenerateTripletWithAminos` from a three-letter nucleotide code and a list of AAs
        which the possibly degenerate code encodes.
        """
        return DegenerateTripletWithAminos(lookup[triplet[0]],
                                           lookup[triplet[1]],
                                           lookup[triplet[2]],
                                           aminos)

    @staticmethod
    def create_multiple_from_triplet_amino_list(triplet_amino_list: List[Tuple[str, str]]) \
            -> List["DegenerateTripletWithAminos"]:
        return [
            DegenerateTripletWithAminos.create_from_string(triplet, amino)
            for triplet, amino in triplet_amino_list
        ]

    @staticmethod
    def set_cover_with_degenerate_code(triplets: Iterable["DegenerateTripletWithAminos"]) \
            -> Set["DegenerateTripletWithAminos"]:
        """
        Reduces the number of given triplets to a smaller subset using degenerate nucleotide code.
        Currently we only consider ones which differ in a single base.

        This is essentially solving a set-cover problem on given set of codons using degenerate code.
        """

        triplets_to_process = list(triplets).copy()  # Shallow copy of the list argument. Serves as a working list.
        degenerate_triplets: Set["DegenerateTripletWithAminos"] = set()

        while len(triplets_to_process) != 0:
            current = triplets_to_process.pop()

            to_keep = []

            for triplet in triplets_to_process:
                # If the 'current' codon matches in two nucleotides, then replace it with a union.
                if current.similarity(triplet) == 2:
                    current = current.union(triplet)
                else:
                    to_keep.append(triplet)  # Keep in the working list

            degenerate_triplets.add(current)  # Add the 'current' (possibly modified) codon to the output list
            triplets_to_process = to_keep

        return degenerate_triplets

    @staticmethod
    def site_separate_set_cover(site_sequence_aminos: List[Set["DegenerateTripletWithAminos"]]) \
            -> List[Set["DegenerateTripletWithAminos"]]:
        """
        Solve the degenerate codon problem for a sequence of mutation sites.
        The algorithm solves the problem for each site separately and then concatenates the solutions.
        Similar to `multi_site_set_cover` but solves the set cover for each site separately.
        """
        return [
            DegenerateTripletWithAminos.set_cover_with_degenerate_code(site)
            for site in site_sequence_aminos
        ]

    @staticmethod
    def multi_site_set_cover(site_sequence_aminos_input: List[Set["DegenerateTripletWithAminos"]]) \
            -> List[Set["DegenerateTripletWithAminos"]]:
        """
        Similar to `set_cover_with_degenerate_code` but makes sure each site has the same number
        of degenerate codons so that we can generate a primer for each.

        If we did sites separately, we might start with 2 sites 3 codons each, and then
        at first site combine everything into a single degenerate codon, while at the second
        site we might have 2-3 degenerate codons. We would then have to duplicate the mutation
        at the first site in multiple primers, which is forbidden by the requirements.
        """

        # We make a copy since the rest of the code is much cleaner if it can consume the input.
        site_sequence_aminos = copy.deepcopy(site_sequence_aminos_input)

        result: List[Set[DegenerateTripletWithAminos]] = [set() for _site in site_sequence_aminos]

        # Each iteration either consumes two elements from each site, or it consumes none and the function returns.
        while True:
            degenerate_candidates = [DegenerateTripletWithAminos.find_two_similar(site)
                                     for site in site_sequence_aminos]

            # We only degenerate if it can be done at all sites at once. Otherwise
            # we wouldn't be able to cover them with primers. We can't do this in single
            # iteration because that would require undo of the iteration if we find
            # a missing candidate in the middle.
            if all(candidate is not None for candidate in degenerate_candidates):
                for i, candidate in enumerate(degenerate_candidates):
                    # This is required for mypy, it doesn't carry over the None check.
                    # See https://github.com/python/mypy/issues/4245
                    assert candidate is not None

                    a, b = candidate
                    result[i].add(a.union(b))

                    site_sequence_aminos[i].remove(a)
                    site_sequence_aminos[i].remove(b)

            # At some point we run out of candidates
            else:
                # Just a sanity check to make sure all sites can be covered by primers.
                site_counts = [len(site) for site in site_sequence_aminos]
                assert len(set(site_counts)) == 1

                for i, site in enumerate(site_sequence_aminos):
                    result[i].update(site)

                return result

    @staticmethod
    def stringified_multi_site_set_cover(site_sequence_aminos: List[Set[str]], forward_table: dict) -> List[Set[str]]:
        """
        Simply wraps `multi_site_set_cover` so that it can be used with the same data structure
        as is used by `SiteSequenceAminos`.
        """
        parsed = DegenerateTripletWithAminos.parse_multi_site_codons(site_sequence_aminos,forward_table)
        solution = DegenerateTripletWithAminos.multi_site_set_cover(parsed)

        return DegenerateTripletWithAminos.stringify_multi_site_codons(solution)

    @staticmethod
    def stringified_site_separate_set_cover(site_sequence_aminos: List[Set[str]], forward_table: dict) -> List[Set[str]]:
        """Same as `stringified_multi_site_set_cover` simply wraps `site_separate_set_cover`"""
        parsed = DegenerateTripletWithAminos.parse_multi_site_codons(site_sequence_aminos, forward_table)
        solution = DegenerateTripletWithAminos.site_separate_set_cover(parsed)

        return DegenerateTripletWithAminos.stringify_multi_site_codons(solution)

    @staticmethod
    def create_subsets_for_primers(degenerate_codons: List[Collection[str]]) -> List[List[str]]:
        """
        Splits codons for a sequence of mutation sites into a list of codons (possibly degenerate), one from each site,
        such that they generate the same amino acids at each site.

        The number of items in the result is always the number of all possible combinations of mutations on all
        sites at the single primer. This combination is found as cartesian product of all possible mutations.

        Return: List of list of codons. Each codon list represents a single primer (with unknown offset and length).
        """

        degenerate_codons_lists = [list(site) for site in degenerate_codons]

        # TODO: this should be the original (non-mutagenic) codon, at the moment we pick random
        #       just to have something working the problem is there is no easy access to the original
        #       codon at this point
        # to_duplicate_codons = [random.choice(site) for site in degenerate_codons_lists]
        # degenerate_site_sequence_codons: List[List[str]] = []
        # while any(len(site) > 0 for site in degenerate_codons_lists):
        #     mutagenic_codons: List[str] = []
        #
        #     # Select (and remove) one codon for each site.
        #     # If there is no remaining codon at some site then use the value of 'to_duplicate_codon' for this site.
        #     for i, site in enumerate(degenerate_codons_lists):
        #         if len(site) > 0:
        #             mutagenic_codons.append(site.pop())
        #         else:
        #             mutagenic_codons.append(to_duplicate_codons[i])
        #
        #     degenerate_site_sequence_codons.append(mutagenic_codons)

        # We should have as many results as there are mutations in the largest site.
        # Note we check against `degenerate_codons` and not `degenerate_codons_lists`,
        # which is consumed during the previous iteration.
        # assert len(degenerate_site_sequence_codons) == max(len(site) for site in degenerate_codons)


        # New version. Basically we need carthesian product between codons on each site
        degenerate_site_sequence_codons: List[List[str]] = []
        all_combinations = itertools.product(*degenerate_codons_lists)
        for comb in all_combinations:
            # itertools product creates tuples-> need to convert it to list
            degenerate_site_sequence_codons.append(list(comb))
        assert len(degenerate_site_sequence_codons) == np.prod([len(site) for site in degenerate_codons])

        return degenerate_site_sequence_codons

    @staticmethod
    def find_two_similar(site: AbstractSet["DegenerateTripletWithAminos"]) \
            -> Optional[Tuple["DegenerateTripletWithAminos", "DegenerateTripletWithAminos"]]:
        """
        Given a set of codons, find the first two which can degenerate together.
        """
        all_pairs = itertools.combinations(site, 2)

        for a, b in all_pairs:
            if a.can_degenerate_with(b):
                return a, b

        return None

    def union(self, triplet):
        return DegenerateTripletWithAminos(self.base1.union(triplet.base1),
                                           self.base2.union(triplet.base2),
                                           self.base3.union(triplet.base3),
                                           self.aminos.union(triplet.aminos))

    def __str__(self):
        return str(self.base1) + str(self.base2) + str(self.base3)

    def __repr__(self):
        return str(self)

    def __key(self):
        return self.base1, self.base2, self.base3

    def __eq__(self, y):
        return self.__key() == y.__key()

    def __hash__(self):
        return hash(self.__key())

    def __len__(self):
        return 3

    def can_degenerate_with(self, other):
        return self.similarity(other) == 2

    def similarity(self, other):
        return (self.base1 == other.base1) + \
               (self.base2 == other.base2) + \
               (self.base3 == other.base3)

    def different_bases(self, other):
        return (self.base1 != other.base1) + \
               (self.base2 != other.base2) + \
               (self.base3 != other.base3)


EMPTY_TRIPLET = DegenerateTripletWithAminos(GAP, GAP, GAP, [])


def parse_degenerate_triplet(triplet, aminos) -> DegenerateTripletWithAminos:
    return DegenerateTripletWithAminos.create_from_string(triplet, aminos)


def union_triplets(triplets: List[DegenerateTripletWithAminos]) -> DegenerateTripletWithAminos:
    result = EMPTY_TRIPLET
    for triplet in triplets:
        result = result.union(triplet)
    return result


def create_full_back_table(forward_table: Dict[str, str]) -> Dict[str, List[str]]:
    back_table: Dict[str, List[str]] = {}

    for triplet, amino in forward_table.items():
        if amino not in back_table:
            back_table[amino] = []
        back_table[amino].append(triplet)

    return back_table


class CodonUsage:
    """
    Hard coded tables: e-coli, yeast
    """
    usages: Dict[str, float]
    table: CodonTable
    back_table: Dict[str, List[str]]
    organism_name: str

    def __init__(self, name: str) -> None:
        self.organism_name = name
        if name == "e-coli":
            self.usages = UsageTable().ecoli_usage
            self.table = CodonTable.unambiguous_dna_by_name["Standard"]
            self.back_table = create_full_back_table(self.table.forward_table)
        elif name == "yeast":
            self.usages = UsageTable().yeast_usage
            self.table = CodonTable.unambiguous_dna_by_name["Standard"]
            self.back_table = create_full_back_table(self.table.forward_table)
        else:
            org = Organism(name)
            self.usages = org.codon_table
            self.table = org.translation_table
            self.back_table = create_full_back_table(self.table.forward_table)

    def get_degenerate_triplet_for_aminos(self, aminos, threshold) -> DegenerateTripletWithAminos:
        per_amino = [self.get_degenerate_triplet_for_amino(amino, threshold) for amino in aminos]
        return union_triplets(per_amino)

    def get_degenerate_triplet_for_amino(self, amino, threshold) -> DegenerateTripletWithAminos:
        return union_triplets(self.get_all_possible_triplets_for_amino(amino, threshold))

    def get_all_possible_triplets_for_amino(self, amino, threshold) -> List[DegenerateTripletWithAminos]:
        all_triplets = self.back_table[amino]
        return [DegenerateTripletWithAminos.create_from_string(triplet, set(amino)) for triplet in all_triplets
                if self.usages[triplet] >= threshold]

    def get_all_possible_triplets_for_aminos(self, aminos, threshold) -> List[DegenerateTripletWithAminos]:
        result = []
        for amino in aminos:
            result.extend(self.get_all_possible_triplets_for_amino(amino, threshold))
        return result

    def get_minimal_triplets_for_aminos(self, aminos: Iterable[str], threshold: float) \
            -> List[Set[DegenerateTripletWithAminos]]:
        possibilities = [self.get_all_possible_triplets_for_amino(amino, threshold)
                         for amino in aminos]

        return [DegenerateTripletWithAminos.set_cover_with_degenerate_code(list(combo))
                for combo in itertools.product(*possibilities)]


# e_coli = CodonUsage("e-coli")
